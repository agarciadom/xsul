/**
 * Capability is the only ticket to a Capability-based Grid service. It is
 * generated by the service provider, and distributed in an appropriate approach
 * to its designated users. The current Capability is based on SAML policy
 * language.
 * <p>
 * A capability comprises of a set of assertions for one instance of a Web
 * service; each assertion corresponds to one owner, one Endpoint Reference and
 * one user. That means there are (# of users x # of actions) assertions for one
 * capability. In the case that there are many users, it would be inefficient to
 * generate these assertions before they are really referred. Therefore, it is
 * strongly suggested to postpone the generation of the real assertions when
 * necessary by setting the postpone flag true.
 *
 * @author    Liang Fang [lifang@cs.indiana.edu]
 * @created   December 16, 2003
 * $Id: Capability.java,v 1.25 2006/02/03 01:58:58 lifang Exp $
 */

package xsul.dsig.saml.authorization;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Vector;
import org.apache.xml.security.signature.XMLSignature;
import org.globus.gsi.GlobusCredential;
import org.opensaml.SAMLAction;
import org.opensaml.SAMLAssertion;
import org.opensaml.SAMLAudienceRestrictionCondition;
import org.opensaml.SAMLAuthorizationDecisionStatement;
import org.opensaml.SAMLException;
import org.opensaml.SAMLNameIdentifier;
import org.opensaml.SAMLSubject;
import xsul.MLogger;
import xsul.XsulException;
import xsul.dsig.saml.authorization.CapConstants;

public class Capability {
    private static final MLogger logger = MLogger.getLogger();
    private static SimpleDateFormat dateformatter =
        new SimpleDateFormat(CapConstants.DATEFORMAT);
    
    private String id = new Long(System.currentTimeMillis()).toString();
    private String owner = "";
    private String resource = "";
    private Collection users;
    private String namespace;
    // optional for web services
    private Map actionswithdecisions;
    private Date notbefore;
    private Date notafter;
    private Collection assertions = new Vector(1);
    // this postponed flag shows whether we should create the assertions
    // immediately, or postpone the assertions generation to when they are being
    // requested. It is more efficient as some of the assertions may never been
    // used even they are assigned, while signature signing and verification are
    // very expensive.
    private boolean signed = false;
    
    public Capability() {
    }
    
    public Capability(Collection _assertions)
        throws CapabilityException {
        this.assertions = _assertions;
        signed = true;
        Iterator iter = assertions.iterator();
        if(iter.hasNext()) {
            SAMLAssertion sa = (SAMLAssertion)iter.next();
            this.owner = sa.getIssuer();
            this.notbefore = sa.getNotBefore();
            this.notafter = sa.getNotOnOrAfter();
            Iterator stiter = sa.getStatements();
            users = new Vector(1);
            while(stiter.hasNext()) {
                SAMLAuthorizationDecisionStatement authorst=null;
                Object o = stiter.next();
                if(o instanceof SAMLAuthorizationDecisionStatement) {
                    authorst = (SAMLAuthorizationDecisionStatement)o;
                    logger.finest("type SAMLAuthorizationDecisionStatement");
                }
                else
                    throw new CapabilityException("illegal SAML statement");
                if(authorst != null) {
                    SAMLSubject subj = authorst.getSubject();
                    String uname = subj.getNameIdentifier().getName();
                    users.add(uname);
                    this.resource = authorst.getResource();
                }
                
                Iterator capactions = authorst.getActions();
                if(capactions == null)
                    throw new CapabilityException("no actions!");
            }
        }
    }
    
    public Capability(File _fsas) {
        try {
            BufferedReader r = new BufferedReader(new FileReader(_fsas));
            StringBuffer sbuf = new StringBuffer();
            int n;
            while((n=r.read())!=-1) {
                sbuf.append((char)n);
            }
            
            extractCapability(sbuf.toString());
        }
        catch(Exception e) {
            e.printStackTrace();
        }
    }
    
    public Capability(InputStream _fstrm) {
        try {
            StringBuffer astr = new StringBuffer();
            int b = _fstrm.read();
            while(b >= 0) {
                astr.append(b);
            }
            
            extractCapability(astr.toString());
        }
        catch(Exception e) {
            e.printStackTrace();
        }
    }
    
    public Capability(String capstr) throws XsulException {
        try {
            extractCapability(capstr);
        }
        catch (SAMLException e) {
            //e.printStackTrace();
            String msg = "could extract asseriotn from " + capstr;
            logger.config(msg, e);
            throw new XsulException(msg, e);
        }
        catch (IOException e) {
            String msg = "could extract asseriotn from " + capstr;
            logger.config(msg, e);
            throw new XsulException(msg, e);
        }
        logger.finest("id: " + id);
    }
    
    /**
     * Constructor
     *
     * @param    _subject            the owner's distinguished name (DN)
     * @param    _ePR                the identifier of the web service
     * @param    _users              A list of users, could be either groupname or users' DNs
     * @param    _nspace             namespace, by default XpolaConstants.LEADNAMESPACE
     * @param    _actionswithdecisionsa  A map file with operation names as keys and decisions as values.
     * It can be null if it is not required to set the operation-level authorization
     * @param    _notbefore          the capability token is not valid before this date
     * @param    _notafter           the capability token is not valid after this date
     * @param    _cred               the owner's GlobusCredential for signing the capability token
     * @param    _postponed          whether to sign it right now or later.
     *
     * @exception   CapabilityException
     *
     */
    public Capability(String _subject,
                      String _ePR,
                      Collection _users,
                      String _nspace,
                      Map _actionswithdecisions,
                      Date _notbefore,
                      Date _notafter,
                      GlobusCredential _cred,
                      boolean _postponed)
        throws CapabilityException {
        owner = CapabilityUtil.canonicalizeSubject(_subject);
        resource = _ePR;
        users = _users;
        namespace = _nspace;
        notbefore = _notbefore;
        notafter = _notafter;
        actionswithdecisions = _actionswithdecisions;
        if(_postponed == true) {
            return;
        }
        
        sign(_cred);
        
    }
    
    public void sign(GlobusCredential _cred) throws CapabilityException {
        if(signed) {
            logger.finest("signed -- not necessary to do it again");
            return;
        }
        
        try {
            GlobusCredential cred = null;
            if(_cred == null)
                cred = GlobusCredential.getDefaultCredential();
            else
                cred = _cred;
            
            if(cred == null) {
                throw new Exception("globus credential can not be null");
            }
            
            // instead of putting all the actions into one assertion, make
            // one assertion for each action for efficiency.
            Iterator uiter = users.iterator();
            while(uiter.hasNext()) {
                String uname = (String)uiter.next();
                String actionname = "access";
                String decision = CapConstants.PERMIT;
                if(actionswithdecisions == null) {
                    SAMLAssertion assertion =
                        makeAssertion(namespace, actionname,
                                      decision, resource,
                                      owner, uname,
                                      notbefore, notafter,
                                      cred);
                    logger.finest(">>>Capability generated>>>>\n"
                                      + assertion.toString());
                    addAssertion(assertion);
                }
                else {
                    Set actions = actionswithdecisions.keySet();
                    Iterator iter = actions.iterator();
                    while(iter.hasNext()) {
                        actionname = (String)iter.next();
                        decision = (String)actionswithdecisions.get(actionname);
                        SAMLAssertion assertion =
                            makeAssertion(namespace, actionname,
                                          decision, resource,
                                          owner, uname,
                                          notbefore, notafter,
                                          cred);
                        logger.finest(">>>Capability generated>>>>\n"
                                          + assertion.toString());
                        addAssertion(assertion);
                    }
                }
            }
        }
        catch(Exception se) {
            String msg  = "capability generation failed: "+ se.getMessage();
            logger.config(msg, se);
            throw new CapabilityException(msg, se);
        }
        logger.finest("capability signed");
        signed = true;
    }
    
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public void setOwner(String owner) {
        this.owner = owner;
    }
    
    public String getOwner() {
        return owner;
    }
    
    public void setResource(String iden) {
        resource = iden;
    }
    
    public String getResource() {
        return resource;
    }
    
    public void setUsers(Collection users) {
        this.users = users;
    }
    
    public Collection getUsers() {
        return users;
    }
    
    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }
    
    public String getNamespace() {
        return namespace;
    }
    
    public void setActionswithdecisions(Map actionswithdecisions) {
        this.actionswithdecisions = actionswithdecisions;
    }
    
    public Map getActionswithdecisions() {
        return actionswithdecisions;
    }
    
    public void setNotbefore(Date notbefore) {
        this.notbefore = notbefore;
    }
    
    public Date getNotbefore() {
        return notbefore;
    }
    
    public void setNotafter(Date notafter) {
        this.notafter = notafter;
    }
    
    public Date getNotafter() {
        return notafter;
    }
    
    public void addAssertion(SAMLAssertion sa) {
        assertions.add(sa);
    }
    
    public SAMLAssertion[] getAllAssertions() {
        return (SAMLAssertion[])assertions.toArray(new SAMLAssertion[0]);
    }
    
    public boolean isSigned() {
        return signed;
    }
    
    public String toString() {
        StringBuffer sb = new StringBuffer("");
        if(signed == true) {
            logger.finest("signed -- print saml assertions");
            SAMLAssertion[] as = getAllAssertions();
            for(int i = 0; i < as.length; i++) {
                sb.append(as[i].toString());
                sb.append("\n");
            }
        }
        else {
            logger.finest("not signed -- print primitive info");
            sb.append("<Capability>\n");
            sb.append("<Id>"+getId()+"</Id>\n");
            sb.append("<Owner>"+getOwner()+"</Owner>\n");
            sb.append("<Resource>"+getResource()+"</Resource>\n");
            sb.append("<Namespace>"+getNamespace()+"</Namespace>\n");
            sb.append("<Notbefore>"+dateformatter.format(notbefore)+"</Notbefore>\n");
            sb.append("<Notafter>"+dateformatter.format(notafter)+"</Notafter>\n");
            Iterator iter = users.iterator();
            while(iter.hasNext()) {
                sb.append("<User>"+(String)iter.next()+"</User>\n");
            }
            if(actionswithdecisions != null) {
                Set actions = actionswithdecisions.keySet();
                iter = actions.iterator();
                while(iter.hasNext()) {
                    String actionname = (String)iter.next();
                    sb.append("<Action>"+actionname+"</Action>");
                    String decision = (String)actionswithdecisions.get(actionname);
                    sb.append("<Decision>"+decision+"</Decision>\n");
                }
            }
            sb.append("</Capability>");
        }
        
        return sb.toString();
    }
    
    public void verify() throws CapabilityException {
        if(signed == false) {
            throw new CapabilityException("not signed yet");
        }
        
        if(isExpired()) {
            throw new CapabilityExpirationException("expired");
        }
        
        Iterator iter = assertions.iterator();
        while(iter.hasNext()) {
            SAMLAssertion sa = (SAMLAssertion)iter.next();
            try {
                sa.verify();
            }
            catch (SAMLException e) {
                e.printStackTrace();
                throw new CapabilityException("Verification failed: "
                                                  + e.getMessage());
            }
        }
        logger.finest("capability verified!!!");
    }
    
    public boolean isExpired() {
        Date rightnow = new Date(System.currentTimeMillis());
        if(notbefore != null && notafter != null) {
            return rightnow.before(notbefore) || rightnow.after(notafter);
        }
        else {
            SAMLAssertion[] as = getAllAssertions();
            // for now, the policy is, if any of them expires,
            // the whole capability expires.
            for(int i = 0; i < as.length; i++) {
                Date notbefore = as[i].getNotBefore();
                Date notonorafter = as[i].getNotOnOrAfter();
                if(rightnow.before(notbefore) || rightnow.after(notonorafter))
                    return true;
            }
        }
        
        return false;
    }
    
    private void extractCapability(String _str)
        throws IOException, SAMLException {
        String capstr = _str;
        
        if (capstr.startsWith("<Capability")) {
            id = capstr.substring(capstr.indexOf("<Id>") + "<Id>".length(),
                                  capstr.indexOf("</Id>"));
            owner = capstr.substring(capstr.indexOf("<Owner>")
                                         + "<Owner>".length(),
                                     capstr.indexOf("</Owner>"));
            resource = capstr.substring(capstr.indexOf("<Resource>")
                                            + "<Resource>".length(),
                                        capstr.indexOf("</Resource>"));
            namespace = capstr.substring(capstr.indexOf("<Namespace>")
                                             + "<Namespace>".length(),
                                         capstr.indexOf("</Namespace>"));
            String notb4str, notafterstr;
            notb4str = capstr.substring(capstr.indexOf("<Notbefore>")
                                            + "<Notbefore>".length(),
                                        capstr.indexOf("</Notbefore>"));
            notafterstr = capstr.substring(capstr.indexOf("<Notafter>")
                                               + "<Notafter>".length(),
                                           capstr.indexOf("</Notafter>"));
            try {
                notbefore = dateformatter.parse(notb4str);
                notafter = dateformatter.parse(notafterstr);
            } catch (ParseException e) {}
            String usersubstr =
                capstr.substring(
                capstr.indexOf("<User>"),
                capstr.lastIndexOf("</User>")+"</User>".length());
            String[] _users = usersubstr.split("</User>\\s*");
            for (int i = 0; i < _users.length; i++) {
                _users[i] = _users[i].substring("<User>".length());
            }
            users = new Vector(Arrays.asList(_users));
            int idx = capstr.indexOf("<Action>");
            if(idx > 0) {
                String actionsubstr =
                    capstr.substring(idx, capstr.lastIndexOf("</Decision>")
                                         + "</Decision>".length());
                String[] actions =
                    actionsubstr.split("</Decision>\\s*");
                actionswithdecisions = new HashMap();
                for (int i = 0; i < actions.length; i++) {
                    String decision = CapConstants.PERMIT;
                    if(actions[i].indexOf(CapConstants.PERMIT) < 0) {
                        decision = CapConstants.DENY;
                    }
                    actions[i] = actions[i].substring(
                        actions[i].indexOf("<Action>") + "<Action>".length(),
                        actions[i].indexOf("</Action>"));
                    actionswithdecisions.put(actions[i], decision);
                }
            }
            signed = false;
        }
        else {
            try {
                int n = capstr.lastIndexOf("<Assertion");
                while(n >= 0) {
                    String substr = capstr.substring(n);
                    //                System.err.println("substring: " + substr);
                    //                System.err.println("b: " + n);
                    capstr = capstr.substring(0, n);
                    ByteArrayInputStream bais =
                        new ByteArrayInputStream(substr.getBytes());
                    SAMLAssertion sa = new SAMLAssertion(bais);
                    signed = sa.isSigned();
                    assertions.add(sa);
                    id = sa.getId();
                    logger.finer("id: " + id);
                    owner = sa.getIssuer();
                    logger.finer("cap owner: " + owner);
                    if(notbefore == null) {
                        notbefore = sa.getNotBefore();
                    }
                    if(notafter == null) {
                        notafter = sa.getNotOnOrAfter();
                    }
                    // a makeshift way to get epr and users
                    int start, end;
                    if(resource == null || resource.equals("")) {
                        end = substr.indexOf("</Audience>");
                        start = substr.indexOf("<Audience>");
                        resource = substr.substring(start+10, end);
                        logger.finer("epr: " + resource);
                    }
                    start = substr.indexOf("<NameIdentifier>");
                    end = substr.indexOf("</NameIdentifier>");
                    String usr = substr.substring(start+16, end);
                    if(users == null) {
                        users = new Vector(11);
                    }
                    if(!users.contains(usr)) {
                        users.add(usr);
                    }
                    bais.close();
                    n = capstr.lastIndexOf("<Assertion");
                }
            }
            catch(Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    private SAMLAssertion makeAssertion(String _nspace,
                                        String _actionname,
                                        String _decision,
                                        String _ePR,
                                        String _ownername,
                                        String _username,
                                        Date _notbefore,
                                        Date _notafter,
                                        GlobusCredential _cred)
        throws CloneNotSupportedException, SAMLException {
        // make AudienceRestrictionCondition
        SAMLAudienceRestrictionCondition sar =
            new SAMLAudienceRestrictionCondition(Collections.singleton(_ePR));
        Vector conditions = new Vector(1);
        conditions.add(sar.clone());
        
        // make AuthorizationDecisionStatement
        String[] confirmationMethods = {SAMLSubject.CONF_BEARER};
        SAMLSubject subject =
            new SAMLSubject(new SAMLNameIdentifier(
                                _username, CapConstants.CAP_NAMEQUALIFIER,
                                CapConstants.CAP_NAMEIDENTIFIER_FORMAT),
                            Arrays.asList(confirmationMethods), null, null);
        SAMLAuthorizationDecisionStatement sad =
            new SAMLAuthorizationDecisionStatement((SAMLSubject)subject.clone(),
                                                   _ePR,
                                                   _decision,
                                                   Collections.singleton(new SAMLAction(_nspace,_actionname)),
                                                   null);
        // make SAML assertion
        SAMLAssertion assertion =
            new SAMLAssertion(_ownername,
                              _notbefore,
                              _notafter,
                              conditions,
                              null,
                              Collections.singleton(sad));
        
        if(_cred != null) {
            assertion.sign(XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA1,
                           _cred.getPrivateKey(),
                           Arrays.asList(_cred.getCertificateChain())
                          );
            if(logger.isFinestEnabled()) {
                logger.finest("ownername: " + _ownername);
                logger.finest("notbefore: " + _notbefore);
                logger.finest("notafter: " + _notafter);
                
                assertion.verify();
            }
        }
        
        return assertion;
    }
    
}



/*
 * Copyright 2001-2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package xsul.util;

import java.util.Random;
//import java.security.SecureRandom;

/**
 * Creates time-based UUID's. See the
 * <a href="http://www.ietf.org/internet-drafts/draft-mealling-uuid-urn-03.txt">UUID Internet Draft</a> for details.
 * <br />Note: code adapted from <a href="http://ws.apache.org/axis/">AXIS</a>
 * <a href="http://svn.apache.org/repos/asf/webservices/axis/trunk/java/src/org/apache/axis/components/uuid/FastUUIDGen.java">source code</a>.
 *
 * @author Jarek Gawor (gawor@apache.org)
 *
 */
public class FastUUIDGen {
    
    private static Random secureRandom;
    
    private static String nodeStr;
    private static int clockSequence;
    
    private static long lastTime = 0;
    
    static {
        init();
    }
    
    private static void init() {
        // problem: the node should be the IEEE 802 ethernet address, but can not
        // be retrieved in Java yet.
        // see bug ID 4173528
        // workaround (also suggested in bug ID 4173528)
        // If a system wants to generate UUIDs but has no IEE 802 compliant
        // network card or other source of IEEE 802 addresses, then this section
        // describes how to generate one.
        // The ideal solution is to obtain a 47 bit cryptographic quality random
        // number, and use it as the low 47 bits of the node ID, with the most
        // significant bit of the first octet of the node ID set to 1. This bit
        // is the unicast/multicast bit, which will never be set in IEEE 802
        // addresses obtained from network cards; hence, there can never be a
        // conflict between UUIDs generated by machines with and without network
        // cards.
//        try {
//            secureRandom = SecureRandom.getInstance("SHA1PRNG", "SUN");
//        } catch (Exception e) {
//            secureRandom = new Random();
//        }
        
        // ALEK
        // we no longer use SecureRandom as it tends to block (indefinitely)
        // on dual processor AMD Opteron machines for us (our tyr cluster)
        secureRandom = new Random();
        
        // ALEK
        // if it blocks with mysterious java.io.FileInputStream.readBytes() blocked from
        // sun.security.provider.SeedGenerator$URLSeedGenerator.getSeedByte()
        // via java.security.SecureRandom.next
        // then try to set -Djava.security.egd=file:/dev/urandom
        // more details in Bug ID: 4705093 Use /dev/urandom rather than /dev/random if it exists.:
        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4705093
        // and on GT4 mailing list:
        // http://www-unix.globus.org/mail_archive/gt4-friends/2005/06/msg00113.html
        //
        nodeStr = getNodeHexValue();
        clockSequence = getClockSequence();
    }
    
    private static String getNodeHexValue() {
        long node = 0;
        long nodeValue = 0;
        while ( (node = getBitsValue(nodeValue, 47, 47)) == 0 ) {
            nodeValue = secureRandom.nextLong();
        }
        node = node | 0x800000000000L;
        return leftZeroPadString(Long.toHexString(node), 12);
    }
    
    private static int getClockSequence() {
        return secureRandom.nextInt(16384);
    }
    
    private static long counter;
    public static String nextUUID_BrainDead() {
        ++counter;
        long time = System.currentTimeMillis();
        return time+"-"+counter;
    };
    
    public static String nextUUID() {
        long time = System.currentTimeMillis();
        
        long timestamp = time * 10000;
        timestamp += 0x01b21dd2L << 32;
        timestamp += 0x13814000;
        
        synchronized(FastUUIDGen.class) {
            if (time - lastTime <= 0) {
                //  http://issues.apache.org/jira/browse/AXIS-1943
                //                int oldClockSequence = clockSequence;
                //                while ( oldClockSequence == clockSequence) {
                //                    clockSequence = getClockSequence();
                //                }
                clockSequence = ((clockSequence + 1) & 16383);
            }
            lastTime = time;
        }
        
        long timeLow = getBitsValue(timestamp, 32, 32);
        long timeMid = getBitsValue(timestamp, 48, 16);
        long timeHi = getBitsValue(timestamp, 64, 16) | 0x1000;
        
        long clockSeqLow = getBitsValue(clockSequence, 8, 8);
        long clockSeqHi = getBitsValue(clockSequence, 16, 8) | 0x80;
        
        String timeLowStr = leftZeroPadString(Long.toHexString(timeLow), 8);
        String timeMidStr = leftZeroPadString(Long.toHexString(timeMid), 4);
        String timeHiStr = leftZeroPadString(Long.toHexString(timeHi), 4);
        
        String clockSeqHiStr = leftZeroPadString(Long.toHexString(clockSeqHi), 2);
        String clockSeqLowStr = leftZeroPadString(Long.toHexString(clockSeqLow), 2);
        
        StringBuffer result = new StringBuffer(36);
        result.append(timeLowStr).append("-");
        result.append(timeMidStr).append("-");
        result.append(timeHiStr).append("-");
        result.append(clockSeqHiStr).append(clockSeqLowStr);
        result.append("-").append(nodeStr);
        
        return result.toString();
    }
    
    private static long getBitsValue(long value, int startBit, int bitLen) {
        return ((value << (64-startBit)) >>> (64-bitLen));
    }
    
    private static final String leftZeroPadString(String bitString, int len) {
        if (bitString.length() < len) {
            int nbExtraZeros = len - bitString.length();
            StringBuffer extraZeros = new StringBuffer();
            for (int i = 0; i < nbExtraZeros; i++) {
                extraZeros.append("0");
            }
            extraZeros.append(bitString);
            bitString = extraZeros.toString();
        }
        return bitString;
    }
    
    private static long runTest(final int COUNT, final int TEST) throws Exception {
        String current = null;
        String prev = null;
        long start = System.currentTimeMillis();
        FastUUIDGen g = new FastUUIDGen();
        for (int i=0;i< COUNT;i++) {
            current = TEST == 1 ? g.nextUUID() : g.nextUUID_BrainDead();
            if (current.equals(prev)) {
                throw new Exception(current + " " + prev);
            }
            prev = current;
        }
        long end = System.currentTimeMillis();
        return end - start;
    }

    public static void main(String [] args) throws Exception {
        init();
        System.err.println("calibrating");
        final int COUNT = 50000;
        long calibrate = runTest(COUNT, 1);
        System.err.println("COUNT="+COUNT+" calibrate="+calibrate+" [ms]");
        final int SECONDS = 10;
        final int COUNT_FOR_SECONDS = (int)((SECONDS * 1000L * COUNT) / calibrate);
        System.err.println("running "+COUNT_FOR_SECONDS+" iterations to have "+SECONDS+" seconds long run");
        long result2 = runTest(COUNT_FOR_SECONDS, 2);
        // got 0.003 [ms] on P4 2Ghz
        printResult("PseudoUUID", result2, COUNT_FOR_SECONDS);
        long result1 = runTest(COUNT_FOR_SECONDS, 1);
        // got 0.01 [ms] on P4 2Ghz
        //printResult("SecureUUID", result1, COUNT_FOR_SECONDS);
        // got 0.01 [ms] on P4 2Ghz
        printResult("RandomUUID", result1, COUNT_FOR_SECONDS);
    }

    private static void printResult(String name, long result, final int COUNT_FOR_SECONDS) {
        System.err.println(name+" finished in : "+((double)(result)/1000.0)+" [s]");
        System.err.println(name+" time for one call: "+((double)(result)/((double)COUNT_FOR_SECONDS))+" [ms]");
        System.err.println(name+" calls per second: "+(int)((1000.0 * COUNT_FOR_SECONDS)/((double)(result)))+"");
    }

}

